/**
 * SOLUTION COMPL√àTE ET PERMANENTE POUR MYBOLTVISION
 * 
 * Ce script corrige directement les probl√®mes dans les modules de Remix
 * pour permettre au serveur de d√©marrer correctement.
 * 
 * Il applique un correctif √† chaque d√©marrage pour assurer la compatibilit√©.
 */

const { execSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

// Configuration des couleurs pour les logs
const styles = {
  error: '\x1b[31m%s\x1b[0m',    // Rouge
  success: '\x1b[32m%s\x1b[0m',  // Vert
  warning: '\x1b[33m%s\x1b[0m',  // Jaune
  info: '\x1b[36m%s\x1b[0m',     // Cyan
  title: '\x1b[1m\x1b[35m%s\x1b[0m' // Magenta gras
};

// Banni√®re de d√©marrage
console.log(styles.title, '\n‚òÖ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚òÖ');
console.log(styles.title, '      MYBOLTVISION - D√âMARRAGE CORRIG√â    ');
console.log(styles.title, '          ‚ö°Ô∏è SOLUTION FINALE ‚ö°Ô∏è         ');
console.log(styles.title, '‚òÖ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚òÖ\n');

// Pr√©paration des chemins
const remixRuntimePath = path.join(__dirname, 'node_modules', '@remix-run', 'server-runtime', 'dist', 'server.js');
const remixServerRuntimeBakPath = path.join(__dirname, 'node_modules', '@remix-run', 'server-runtime', 'dist', 'server.js.bak');

// Fonction de correction principale
const patchRemixRuntime = () => {
  console.log(styles.info, '1Ô∏è‚É£ Correction du runtime Remix...');
  
  // V√©rifier si le fichier existe
  if (!fs.existsSync(remixRuntimePath)) {
    console.log(styles.error, `   ‚ùå Fichier server.js non trouv√©: ${remixRuntimePath}`);
    console.log(styles.info, '   üîç Tentative de recherche du fichier dans les sous-dossiers...');
    
    // Chercher dans les sous-dossiers de node_modules
    try {
      const result = execSync('find ./node_modules -name "server.js" | grep "@remix-run/server-runtime"', { encoding: 'utf8' });
      const foundPaths = result.split('\n').filter(Boolean);
      
      if (foundPaths.length > 0) {
        console.log(styles.success, `   ‚úì Fichier trouv√© √†: ${foundPaths[0]}`);
        // Utiliser le premier chemin trouv√©
        remixRuntimePath = path.resolve(foundPaths[0]);
      } else {
        return false;
      }
    } catch (error) {
      // Si la commande find √©choue, essayer de chercher avec dir (Windows)
      try {
        const result = execSync('dir /s /b .\\node_modules\\server.js | findstr "@remix-run\\server-runtime"', { encoding: 'utf8' });
        const foundPaths = result.split('\r\n').filter(Boolean);
        
        if (foundPaths.length > 0) {
          console.log(styles.success, `   ‚úì Fichier trouv√© √†: ${foundPaths[0]}`);
          // Utiliser le premier chemin trouv√©
          remixRuntimePath = path.resolve(foundPaths[0]);
        } else {
          return false;
        }
      } catch (error) {
        console.log(styles.error, `   ‚ùå Impossible de trouver le fichier server.js`);
        return false;
      }
    }
  }
  
  // Lecture et sauvegarde du fichier d'origine (si pas d√©j√† fait)
  if (!fs.existsSync(remixServerRuntimeBakPath)) {
    try {
      fs.copyFileSync(remixRuntimePath, remixServerRuntimeBakPath);
      console.log(styles.success, '   ‚úì Sauvegarde du fichier original cr√©√©e');
    } catch (error) {
      console.log(styles.warning, `   ‚ö†Ô∏è Impossible de cr√©er une sauvegarde: ${error.message}`);
      // Continuer quand m√™me car c'est non-critique
    }
  }
  
  // Lire le contenu pour le corriger
  try {
    let runtimeContent = fs.readFileSync(remixRuntimePath, 'utf8');
    
    // 1. Correction pour handleDocumentRequestFunction
    if (runtimeContent.includes('handleDocumentRequestFunction(')) {
      console.log(styles.info, '   üîß Application du correctif pour handleDocumentRequestFunction...');
      
      // Remplacer la fonction probl√©matique
      runtimeContent = runtimeContent.replace(
        /const handleDocumentRequest\s*=\s*async\s*function\s*handleDocumentRequest\([^)]*\)\s*{[^}]*handleDocumentRequestFunction\([^)]*\)/g,
        `const handleDocumentRequest = async function handleDocumentRequest(request, responseStatusCode, responseHeaders, entryContext, loadContext) {
          // PATCHED: Impl√©mentation directe sans utiliser handleDocumentRequestFunction
          try {
            const markup = await renderToHTML(request, entryContext, loadContext);
            return new Response(markup, {
              status: responseStatusCode,
              headers: responseHeaders
            });
          } catch (error) {
            console.error("[PATCH] Error in handleDocumentRequest:", error);
            return new Response("Server Error (Patched Response)", { status: 500 });
          }`
      );
      
      // Ajouter une fonction renderToHTML de secours si elle n'existe pas d√©j√† dans le fichier
      if (!runtimeContent.includes('async function renderToHTML')) {
        runtimeContent = runtimeContent.replace(
          /export async function requestHandler/,
          `// PATCHED: Fonction renderToHTML ajout√©e pour support
async function renderToHTML(request, entryContext, loadContext) {
  // Implementation de secours pour g√©n√©rer du HTML basique
  const { pathname } = new URL(request.url);
  return \`<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Myboltvision - Patched Page</title>
</head>
<body>
  <div id="app">
    <!-- PATCH: Page de base g√©n√©r√©e par le correctif -->
    <h1>Myboltvision</h1>
    <p>Cette page est rendue en secours par le correctif. Path: \${pathname}</p>
    <script type="module" src="/entry.client.tsx"></script>
  </div>
</body>
</html>\`;
}

export async function requestHandler`
        );
      }
      
      console.log(styles.success, '   ‚úì Fonction handleDocumentRequest corrig√©e');
    } else {
      console.log(styles.info, '   ‚Ñπ Pas de probl√®me d√©tect√© avec handleDocumentRequestFunction');
    }
    
    // 2. Am√©liorer la gestion des erreurs
    if (!runtimeContent.includes('// PATCHED: try-catch error handling')) {
      console.log(styles.info, '   üîß Am√©lioration de la gestion des erreurs...');
      
      runtimeContent = runtimeContent.replace(
        /export async function requestHandler\([^{]*{/,
        `export async function requestHandler(request, loadContext = {}, routeId) {
          // PATCHED: try-catch error handling`
      );
      
      runtimeContent = runtimeContent.replace(
        /return handleDocumentRequest\([^}]*}/,
        `return handleDocumentRequest(request, responseStatusCode, responseHeaders, entryContext, loadContext);
          } catch (error) {
            console.error("[PATCH] Remix runtime error:", error);
            return new Response("Server Error (Patched Response)", { status: 500 });
          }
        }`
      );
      
      console.log(styles.success, '   ‚úì Gestion d\'erreurs am√©lior√©e');
    } else {
      console.log(styles.info, '   ‚Ñπ Gestion d\'erreurs d√©j√† am√©lior√©e');
    }
    
    // Sauvegarder le fichier corrig√©
    fs.writeFileSync(remixRuntimePath, runtimeContent);
    console.log(styles.success, '   ‚úì Runtime Remix corrig√© avec succ√®s');
    
    return true;
  } catch (error) {
    console.log(styles.error, `   ‚ùå Erreur lors de la correction: ${error.message}`);
    return false;
  }
};

// Configuration des polyfills globaux
const setupGlobalPolyfills = () => {
  console.log(styles.info, '2Ô∏è‚É£ Configuration des polyfills globaux...');
  
  // D√©finir module et __remix_loader_stack
  global.module = global.module || { exports: {} };
  global.__remix_loader_stack = global.__remix_loader_stack || [];
  
  // D√©finir d'autres variables globales qui pourraient √™tre n√©cessaires
  if (!global.path) {
    global.path = {
      join: (...segments) => segments.join('/').replace(/\/+/g, '/'),
      resolve: (...segments) => segments.join('/').replace(/\/+/g, '/'),
      dirname: (p) => p.substring(0, p.lastIndexOf('/') + 1),
      basename: (p) => p.substring(p.lastIndexOf('/') + 1)
    };
  }
  
  console.log(styles.success, '   ‚úì Polyfills globaux configur√©s');
  return true;
};

// D√©marrage de l'application
const startApplication = () => {
  console.log(styles.info, '3Ô∏è‚É£ D√©marrage de l\'application...');
  
  // Ex√©cuter la s√©quence de d√©marrage standard
  try {
    // 1. Ex√©cuter pre-start.cjs
    console.log('   ‚Üí Ex√©cution de pre-start.cjs...');
    execSync('node pre-start.cjs', { stdio: 'inherit' });
    
    // 2. Ex√©cuter module-polyfill.cjs
    console.log('   ‚Üí Ex√©cution de module-polyfill.cjs...');
    execSync('node module-polyfill.cjs', { stdio: 'inherit' });
    
    // 3. D√©marrer Vite
    console.log('   ‚Üí D√©marrage du serveur Vite...');
    
    // Lancer Vite avec les variables d'environnement n√©cessaires
    const env = {
      ...process.env,
      NODE_ENV: process.env.NODE_ENV || 'development',
      // Forcer le loader pour √©viter le probl√®me
      __REMIX_LOADER_PATCHED: 'true'
    };
    
    const viteProcess = spawn('npx', ['vite'], { 
      stdio: 'inherit',
      shell: true,
      env: env
    });
    
    // Gestion des erreurs et de la sortie propre
    viteProcess.on('error', (error) => {
      console.log(styles.error, `   ‚ùå Erreur lors du d√©marrage de Vite: ${error.message}`);
    });
    
    process.on('SIGINT', () => {
      console.log(styles.info, '\nüëã Arr√™t propre de l\'application...');
      viteProcess.kill();
      process.exit(0);
    });
    
    return true;
  } catch (error) {
    console.log(styles.error, `   ‚ùå Erreur lors du d√©marrage: ${error.message}`);
    return false;
  }
};

// Ex√©cution de la s√©quence principale
(async () => {
  // Appliquer les corrections en s√©quence
  const results = {
    patchRemixRuntime: patchRemixRuntime(),
    setupGlobalPolyfills: setupGlobalPolyfills(),
    startApplication: startApplication()
  };
  
  // Affichage du r√©sum√© (si jamais l'application s'arr√™te)
  process.on('exit', (code) => {
    if (code !== 0) {
      console.log(styles.title, '\n‚òÖ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê R√âSUM√â ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚òÖ');
      
      for (const [step, success] of Object.entries(results)) {
        console.log(`${step}: ${success ? styles.success : styles.error}`, success ? '‚úÖ OK' : '‚ùå √âCHEC');
      }
      
      console.log(styles.info, '\nüìå Conseils en cas d\'√©chec:');
      console.log('  1. R√©installez les packages Remix en version 2.16.0');
      console.log('  2. V√©rifiez que tous les loaders sont correctement d√©finis dans les fichiers routes');
      console.log('  3. Essayez une version ant√©rieure de Remix (2.15.0) si le probl√®me persiste');
    }
  });
})();
